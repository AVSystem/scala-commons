# `GenCodec`

AVSystem commons library contains a typesafe, typeclass-based serialization framework, similar to other Scala serialization libraries like [uPickle](http://www.lihaoyi.com/upickle-pprint/upickle/).

* Typeclass based - type `T` can be serialized/deserialized when there is an implicit `GenCodec[T]` available
* Typesafe - thanks to how typeclasses work in Scala, serialized types are thoroughly validated to determine whether they are serializable or not. For example `List[T]` is serializable only when `T` is serializable. This validation goes arbitrary levels deep and is done fully in compile time.
* Serialization format agnostic - support for any JSON-like serialization format that supports the generic concept of lists and objects/maps can be easily implemented.
* Macros for automatic derivation of codecs for case classes (and case class like types) and sealed hierarchies. This includes complex types like recursively-defined case classes and GADTs.
* Auto-generated codecs can be customized with annotations.
* Two modes of operation - explicit (requires explicit declaration of `GenCodec` for every type) and automatic (codecs are always automatically generated by macros if possible).

The central trait of the framework is the `GenCodec` typeclass:

```scala
trait GenCodec[T] {
  def read(input: Input): T
  def write(output: Output, value: T): Unit
}
```

A `GenCodec[T]` can read a value of type `T` from an `Input` and write a value of type `T` to an `Output`. `Input` and `Output` are abstract, raw, stream-like, mutable entities which perform the actual serialization and deserialization using some  particularformat hardwired into them, like JSON. Therefore, `GenCodec` by itself is not bound to any format. It only depends on the fact that this format is capable of serializing following types and structures:
* integer numbers up to at least 64-bit precision (i.e. `Long`)
* decimal numbers up to at least 64-bit precision (i.e. `Double`)
* `Char`s, `String`s, `Boolean`s and `null`s
* arbitrary byte chunks
* millisecond-precision timestamps
* arbitrarily nested sequences (lists)
* arbitrarily nested objects, i.e. string-to-value mappings
Of course, if some type is not "natively" supported by some serialization format, it can be supported by representing it with one of the primitive types. For example, timestamps may be serialized simply as `Long` values containing the number of milliseconds since 01.01.1970.

The commons library contains example implementation of `Input` and `Output` - `SimpleValueInput` and `SimpleValueOutput` which translate serialized values to simple Scala objects. Primitive types are represented by themselves, lists are represented by standard Scala `List[T]` values and objects are represented by standard Scala `Map[String,T]` values. You can use this representation as an intermediate representation that can be further serialized e.g. by some Java serialization framework. However, for performance reasons it is recommended to have direct implementations of `Input` and `Output` for the final format.

## Codecs available by default

In order to serialize/deserialize value of some type, there needs to be an implicit value of type `GenCodec[T]` available.
The library by default provides codecs for common Scala and Java types:
* `Unit`, `Null`, `String`, `Char`, `Boolean`, `Byte`, `Short`, `Int`, `Long`, `Float`, `Double`, `java.util.Date`, `Array[Byte]` and all their Java boxed counterparts (like `java.lang.Integer`).
* Any Scala tuple, provided that every tuple element type can be serialized
* Any `Array[T]`, provided that `T` can be serialized
* Any Scala collection extending `scala.collection.Seq[T]` or `scala.collection.Set[T]`, provided that `T` can be serialized
* Any `java.util.Collection[T]`, provided that `T` can be serialized
* Any `scala.collection.Map[K,V]` provided that `K` and `V` can be serialized. By default, maps are serialized as lists of key-value pairs, unless there is an implicit `GenKeyCodec` available for the key type `K` (see later). In that case, keys can be represented as `String`s and the map can be serialized as an object.
* Any `java.util.Map[K,V]`, provided that `K` and `V` can be serialized. `GenKeyCodec` existence for `K` applies in the same way as for Scala `Map`.
* `Option[T]`, `Opt[T]`, `NOpt[T]`, `OptRef[T]`, provided that `T` can be serialized.

### `GenKeyCodec`

For serialization of maps, there is an auxilliary typeclass - `GenKeyCodec`. It provides the ability to translate values of some type into `String` keys that can be used as object keys by `GenCodec`s for Scala and Java `Map` types. By default, following types have `GenKeyCodec` provided:
* `String`
* `Boolean`, `Char`, `Byte`, `Short`, `Int`, `Long`
* `JBoolean`, `JCharacter`, `JByte`, `JShort`, `JInteger`, `JLong`
If there is no `GenKeyCodec` available for some type `K`, then `Map[K,V]` will be serialized into a list of key-value pairs (each pair represented as an object with two fields).

## Serializing and deserializing examples

To serialize and deserialize values, you can use the `GenCodec#read` and `GenCodec#write` methods directly. However, the `GenCodec` companion object contains `read` and `write` methods which atomatically capture implicitly availabe `GenCodec` and use it (resulting in shorter syntax).

Here are some simple examples of serialization using `SimpleValueOutput` and `SimpleValueInput`:

```scala
import com.avsystem.commons.serialization._

def simpleWrite[T: GenCodec](t: T): Any = {
  var result: Any = null
  GenCodec.write[T](new SimpleValueOutput(result = _), t)
  result
}

def simpleRead[T: GenCodec](raw: Any): T =
  GenCodec.read[T](new SimpleValueInput(raw))
  
// primitive types like `Int` are represented by themselves
val raw = simpleWrite[Int](123) // 123
simpleRead[Int](raw) // 123

// `Option`s are represented using empty list or single-element list
val raw = simpleWrite[Option[String]](Some("sth")) // List("sth")
simpleRead[Option[String]](raw) // Some("sth")

val raw = simpleWrite[Option[String]](None) // List()
simpleRead[Option[String]](raw) // None

// all collections are represented as lists
val raw = simpleWrite(Set(1,2,3)) // List(1,2,3)
simpleRead[Set[Int]](raw) // Set(1,2,3)

// maps are represented as Scala maps
val raw = simpleWrite(Map("1" -> 1, "2" -> 2)) // Map("1" -> 1, "2" -> 2)
simpleRead[Map[String,Int]](raw) // Map("1" -> 1, "2" -> 2)

// maps without GenKeyCodec for key type are represented as lists of key-value pairs
val raw = simpleWrite(Map(1.0 -> 1, 2.0 -> 2)) // List(Map("key" -> 1.0, "value" -> 1), Map("key" -> 2.0, "value" -> 2))
simpleRead[Map[Double,Int]](raw) // Map(1.0 -> 1, 2.0 -> 2)

// tuples are represented as lists
val raw = simpleWrite((1, "sth", 2.0)) // List(1, "sth", 2.0)
simpleRead[(Int,String,Double)](raw) // (1, "sth", 2.0)
```

## Making your own types serializable

In order to make your own (or third-party) classes and types serializable, you need to provide an instance of `GenCodec` for it. You can implement it manually, e.g.

```scala
case class Person(name: String, birthYear: Int)
object Person {
  implicit val codec: GenCodec[Person] = GenCodec.create(...)
}
```

### Automatic generation of codecs

The previous example intentionally omits the actual implementation, because you rarely need to provide it yourself. If your type is a case class or sealed hierarchy of case classes/objects, then you can generate codec implementation using the `GenCodec.materialize` macro.

#### Case classes

```scala
case class Person(name: String, birthYear: Int)
object Person {
  implicit val codec: GenCodec[Person] = GenCodec.materialize[Person]
}
```

#### Sealed hierarchies

If you materialize a `GenCodec` for sealed hierarchy, make sure that the macro is used in source code after all case classes and object have been defined:

```scala
sealed trait Timeout
case class FiniteTimeout(seconds: Int) extends Timeout
case object InfiniteDuration extends Timeout
object Timeout {
  implicit val codec: GenCodec[Timeout] = GenCodec.materialize[Timeout]
}
```

This requirement is caused by a limitation in Scala macros - see [SI-7046](https://issues.scala-lang.org/browse/SI-7046) for more details. If you use static analyzer provided by AVSystem commons library (`commons-analyzer`), the compiler will protect you by issuing an error if you invoke macro in wrong place. This is recommended - otherwise there is a risk that the codec implementation is incomplete and will crash in runtime.

#### Codec dependencies

The `materialize` macro will only generate a `GenCodec` implementation for case class or sealed hierarchy if all fields of case classes are already serializable (i.e. they have a `GenCodec` independently declared). For example, the following code will not compile:

```scala
case class Address(city: String, zipcode: String)
case class Person(name: String, address: Address)
object Person {
  implicit val codec: GenCodec[Person] = GenCodec.materialize[Person] // error!
}
```

The `materialize` macro does not descend into case class fields and will therefore refuse to generate codec for `Person` because it doesn't have a codec for `Address`. This behavior is intentional and serves to avoid making types serializable by accident. However, there is an alternative macro which *does* descend into dependencies, `GenCodec.materializeRecursively`:

```scala
case class Address(city: String, zipcode: String)
case class Person(name: String, address: Address)
object Person {
  implicit val codec: GenCodec[Person] = GenCodec.materializeRecursively[Person]
}
```

`materializeRecursively` will generate a codec for `Address`. However, this codec will be visible only by the `Person` codec. That means you can now serialize `Person` objects, but you still can't serialize `Address` objects by themselves. Also, remember that `materializeRecursively` descends into dependencies only when it actually needs to do it, i.e. first it tries to use any already declared `GenCodec`.

