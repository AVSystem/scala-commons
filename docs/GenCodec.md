# [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html)

AVSystem commons library contains a typesafe, typeclass-based serialization framework, similar to other Scala 
serialization libraries like [uPickle](http://www.lihaoyi.com/upickle-pprint/upickle/).

**[API reference](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/index.html)**

Features:
* Typeclass based - type `T` can be serialized/deserialized when there is an implicit `GenCodec[T]` available
* Typesafe - thanks to how typeclasses work in Scala, serialized types are thoroughly validated to determine whether 
  they are serializable or not. For example `List[T]` is serializable only when `T` is serializable. This validation 
  goes arbitrary levels deep and is done fully in compile time.
* Serialization format agnostic - support for any JSON-like serialization format that supports the generic concept 
  of lists and objects/maps can be easily implemented.
* Macros for automatic derivation of codecs for case classes (and case class like types) and sealed hierarchies. 
  This includes complex types like recursively-defined case classes and GADTs.
* Auto-generated codecs can be customized with annotations.
* Two modes of operation - explicit (requires explicit declaration of [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html) 
  for every type) and automatic (codecs are always automatically generated by macros if possible).

## Table of Contents

  * [`GenCodec` typeclass](#gencodec-typeclass)
  * [Codecs available by default](#codecs-available-by-default)
    * [GenKeyCodec ](#genkeycodec)
  * [Serializing and deserializing examples](#serializing-and-deserializing-examples)
  * [Making your own types serializable](#making-your-own-types-serializable)
    * [Automatic generation of codecs](#automatic-generation-of-codecs)
      * [Case classes](#case-classes)
      * [Sealed hierarchies](#sealed-hierarchies)
      * [Singletons](#singletons)
      * [Codec dependencies](#codec-dependencies)
      * [Types supported by automatic materialization](#types-supported-by-automatic-materialization)
      * [Recursive types, generic types and GADTs (generalized algebraic data types)](#recursive-types-generic-types-and-gadts-generalized-algebraic-data-types)
    * [Fully automatic mode - `GenCodec.Auto`](#fully-automatic-mode---gencodecauto)
      * [Explicit vs automatic mode](#explicit-vs-automatic-mode)
    * [Customizing macro-materialized codecs](#customizing-macro-materialized-codecs)
      * [Safely introducing changes to serialized classes (retaining backwards compatibility)](#safely-introducing-changes-to-serialized-classes-retaining-backwards-compatibility)

## [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html) typeclass

The central trait of the framework is the [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html) typeclass:

```scala
trait GenCodec[T] {
  def read(input: Input): T
  def write(output: Output, value: T): Unit
}
```

A `GenCodec[T]` can read a value of type `T` from an [`Input`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/Input.html) 
and write a value of type `T` to an [`Output`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/Output.html). 
[`Input`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/Input.html) and [`Output`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/Output.html) are abstract, raw, stream-like, mutable entities which perform the actual serialization and 
deserialization using some  particular format hardwired into them, like JSON. Therefore, [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html) by itself is not 
bound to any format. It only depends on the fact that this format is capable of serializing following types and structures:
* integer numbers up to at least 64-bit precision (i.e. `Long`)
* decimal numbers up to at least 64-bit precision (i.e. `Double`)
* `Char`s, `String`s, `Boolean`s and `null`s
* arbitrary byte chunks
* millisecond-precision timestamps
* arbitrarily nested sequences (lists)
* arbitrarily nested objects, i.e. string-to-value mappings

Of course, if some type is not "natively" supported by some serialization format, it can be supported by representing 
it with one of the primitive types. For example, timestamps may be serialized simply as `Long` values containing the 
number of milliseconds since 01.01.1970.

The commons library contains example implementation of [`Input`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/Input.html) 
and [`Output`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/Output.html) - 
[`SimpleValueInput`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/SimpleValueInput.html) 
and [`SimpleValueOutput`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/SimpleValueOutput.html) 
which translate serialized values to simple Scala objects. Primitive types are represented by themselves, lists are 
represented by standard Scala `List[T]` values and objects are represented by standard Scala `Map[String,T]` values. 
You can use this representation as an intermediate representation that can be further serialized e.g. by some Java 
serialization framework. However, for performance reasons it is recommended to have direct implementations of 
[`Input`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/Input.html) 
and [`Output`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/Output.html) for the final format.

## Codecs available by default

In order to serialize/deserialize value of some type, there needs to be an implicit value of type `GenCodec[T]` available.
The library by default provides codecs for common Scala and Java types:
* `Unit`, `Null`, `String`, `Char`, `Boolean`, `Byte`, `Short`, `Int`, `Long`, `Float`, `Double`, `java.util.Date`, 
  `Array[Byte]` and all their Java boxed counterparts (like `java.lang.Integer`).
* Any Scala tuple, provided that every tuple element type can be serialized
* Any `Array[T]`, provided that `T` can be serialized
* Any Scala collection extending `scala.collection.Seq[T]` or `scala.collection.Set[T]`, provided that `T` can be serialized
* Any `java.util.Collection[T]`, provided that `T` can be serialized
* Any `scala.collection.Map[K,V]` provided that `K` and `V` can be serialized. By default, maps are serialized as lists 
  of key-value pairs, unless there is an implicit `GenKeyCodec` available for the key type `K` (see later). 
  In that case, keys can be represented as `String`s and the map can be serialized as an object.
* Any `java.util.Map[K,V]`, provided that `K` and `V` can be serialized. [`GenKeyCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenKeyCodec.html) 
  existence for `K` applies in the same way as for Scala `Map`.
* `Option[T]`, `Opt[T]`, `OptArg[T]`, `NOpt[T]`, `OptRef[T]`, provided that `T` can be serialized.
* [`NamedEnum`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/misc/NamedEnum.html)s 
  whose companion object extends [`NamedEnumCompanion`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/misc/NamedEnumCompanion.html)
* Java enums

### [`GenKeyCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenKeyCodec.html)

For serialization of maps, there is an auxilliary typeclass - [`GenKeyCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenKeyCodec.html). 
It provides the ability to translate values of some type into `String` keys that can be used as object keys by 
[`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html)s for Scala 
and Java `Map` types. By default, following types have [`GenKeyCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenKeyCodec.html) provided:
* `String`
* `Boolean`, `Char`, `Byte`, `Short`, `Int`, `Long`
* `JBoolean`, `JCharacter`, `JByte`, `JShort`, `JInteger`, `JLong`
* [`NamedEnum`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/misc/NamedEnum.html)s 
  whose companion object extends [`NamedEnumCompanion`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/misc/NamedEnumCompanion.html)
* Java enums
If there is no [`GenKeyCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenKeyCodec.html) 
available for some type `K`, then `Map[K,V]` will be serialized into a list of key-value 
pairs (each pair represented as an object with two fields).

## Serializing and deserializing examples

To serialize and deserialize values, you can use the [`read`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html#read(input:com.avsystem.commons.serialization.Input):T) 
and [`write`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html#write(output:com.avsystem.commons.serialization.Output,value:T):Unit) 
methods directly. However, the [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$.html) 
companion object also contains [`read`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$.html#read[T](input:com.avsystem.commons.serialization.Input)(implicitcodec:com.avsystem.commons.serialization.GenCodec[T]):T) 
and [`write`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$.html#write[T](output:com.avsystem.commons.serialization.Output,value:T)(implicitcodec:com.avsystem.commons.serialization.GenCodec[T]):Unit) 
methods which automatically capture implicitly available [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html) 
and use it (resulting in shorter syntax).

Here are some simple examples of serialization using [`SimpleValueOutput`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/SimpleValueOutput.html) 
and [`SimpleValueInput`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/SimpleValueInput.html):

```scala
import com.avsystem.commons.serialization._

def simpleWrite[T: GenCodec](t: T): Any = {
  var result: Any = null
  GenCodec.write[T](new SimpleValueOutput(result = _), t)
  result
}

def simpleRead[T: GenCodec](raw: Any): T =
  GenCodec.read[T](new SimpleValueInput(raw))
  
// primitive types like `Int` are represented by themselves
val raw = simpleWrite[Int](123) // 123
simpleRead[Int](raw) // 123

// `Option`s are represented using empty list or single-element list
val raw = simpleWrite[Option[String]](Some("sth")) // List("sth")
simpleRead[Option[String]](raw) // Some("sth")

val raw = simpleWrite[Option[String]](None) // List()
simpleRead[Option[String]](raw) // None

// all collections are represented as lists
val raw = simpleWrite(Set(1,2,3)) // List(1,2,3)
simpleRead[Set[Int]](raw) // Set(1,2,3)

// maps are represented as Scala maps
val raw = simpleWrite(Map("1" -> 1, "2" -> 2)) // Map("1" -> 1, "2" -> 2)
simpleRead[Map[String,Int]](raw) // Map("1" -> 1, "2" -> 2)

// maps without GenKeyCodec for key type are represented as lists of key-value pairs
val raw = simpleWrite(Map(1.0 -> 1, 2.0 -> 2)) // List(Map("key" -> 1.0, "value" -> 1), Map("key" -> 2.0, "value" -> 2))
simpleRead[Map[Double,Int]](raw) // Map(1.0 -> 1, 2.0 -> 2)

// tuples are represented as lists
val raw = simpleWrite((1, "sth", 2.0)) // List(1, "sth", 2.0)
simpleRead[(Int,String,Double)](raw) // (1, "sth", 2.0)
```

## Making your own types serializable

In order to make your own (or third-party) classes and types serializable, you need to provide an instance of 
[`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html) 
for it. You can implement it manually, e.g.

```scala
case class Person(name: String, birthYear: Int)
object Person {
  implicit val codec: GenCodec[Person] = GenCodec.create(...)
}
```

### Automatic generation of codecs

The previous example intentionally omits the actual implementation, because you rarely need to provide it yourself. 
If your type is a case class or sealed hierarchy of case classes/objects, then you can generate codec implementation 
using the [`GenCodec.materialize`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$.html#materialize[T]:com.avsystem.commons.serialization.GenCodec[T])
macro.

#### Case classes

```scala
case class Person(name: String, birthYear: Int)
object Person {
  implicit val codec: GenCodec[Person] = GenCodec.materialize[Person]
}
```

The macro-materialized codec for case class serializes it into an object where field names serve as keys and field 
values as associated values. For example, `Person("Fred", 1990)` would be represented (using 
[`SimpleValueWriter`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/SimpleValueWriter.html))
as `Map("name" -> "Fred", "birthYear" -> 1990)`

This can be customized with annotations (see later)

#### Sealed hierarchies

Materialization of [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html)
also works for sealed hierarchies with case classes and objects:

```scala
sealed trait Timeout
case class FiniteTimeout(seconds: Int) extends Timeout
case object InfiniteTimeout extends Timeout
object Timeout {
  implicit val codec: GenCodec[Timeout] = GenCodec.materialize[Timeout]
}
```

Values of such types are serialized into objects with one field where key is the name of case class or object used and 
value is the serialized case class or object itself. For example, `FiniteTimeout(60)` would be represented 
(using [`SimpleValueWriter`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/SimpleValueWriter.html)) 
as `Map("FiniteTimeout" -> Map("seconds" -> 60))`

You need to be careful about where you invoke the [`materialize`]((http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$.html#materialize[T]:com.avsystem.commons.serialization.GenCodec[T]))
macro. It should always be done *after* all case classes and objects in you sealed hierarchy have already been defined - 
like in the example above, where companion object `Timeout` (which contains macro invocation) is defined after `FiniteTimeout` and `InfiniteTimeout`.

The above requirement is caused by a limitation in Scala macros - see [SI-7046](https://issues.scala-lang.org/browse/SI-7046) 
for more details. If you use static analyzer provided by AVSystem commons library (`commons-analyzer`), the compiler will 
protect you by issuing an error if you invoke macro in wrong place. This is recommended - otherwise there is a risk that 
the codec implementation is incomplete and will crash in runtime.

#### Singletons

`materialize` macro is also able to generate (trivial) codecs for singletons, i.e. `object`s or types like `this.type`.
Singletons always serialize into empty object. When using [`SimpleValueWriter`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/SimpleValueWriter.html), 
empty object is represented by empty `Map`.

```scala
object SomeObject {
  implicit val codec: GenCodec[SomeObject.type] = GenCodec.materialize[SomeObject.type]
}
```

#### Codec dependencies

The `materialize` macro will only generate [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html) 
implementation for case class or sealed hierarchy if all fields of case classes are already serializable 
(i.e. their types have their own [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html) 
instances). For example, the following code will not compile:

```scala
case class Address(city: String, zipcode: String)
case class Person(name: String, address: Address)
object Person {
  implicit val codec: GenCodec[Person] = GenCodec.materialize[Person] // error!
}
```

The `materialize` macro does not descend into case class fields and will therefore refuse to generate codec for `Person` 
because it doesn't have a codec for `Address`. This behavior is intentional and serves to avoid making types serializable 
by accident. However, there is an alternative macro which *does* descend into dependencies, 
[`GenCodec.materializeRecursively`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$.html#materializeRecursively[T]:com.avsystem.commons.serialization.GenCodec[T]):

```scala
case class Address(city: String, zipcode: String)
case class Person(name: String, address: Address)
object Person {
  implicit val codec: GenCodec[Person] = GenCodec.materializeRecursively[Person]
}
```

`materializeRecursively` will generate a codec for `Address`. However, this codec will be visible only by the `Person` codec. 
That means you can now serialize `Person` objects, but you still can't serialize `Address` objects by themselves. Also, 
remember that `materializeRecursively` descends into dependencies only when it actually needs to do it, i.e. first it 
tries to use any already declared [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html).

#### Types supported by automatic materialization

To be precise, `materialize` and `materializeRecursively` macros work for:
* case classes, provided that all field types are serializable
* case class like types, i.e. classes or traits whose companion object contains a pair of matching `apply`/`unapply` 
  methods defined like in case class companion, provided that all field types are serializable
* singleton types, e.g. types of `object`s or `this.type`
* sealed traits or abstract classes, provided that every non-abstract subtype is serializable or
  [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html) can also 
  be automatically materialized for them

#### Recursive types, generic types and GADTs (generalized algebraic data types)

`materialize` and `materializeRecursively` support recursive and generic types, e.g.

```scala
case class SimpleTree(children: List[SimpleTree])
object SimpleTree {
  implicit val codec: GenCodec[SimpleTree] = GenCodec.materialize[SimpleTree]
}
```

```scala
sealed trait Tree[T]
case class Leaf[T](value: T) extends Tree[T]
case class Branch[T](left: Tree[T], right: Tree[T]) extends Tree[T]
object Tree {
  implicit def codec[T: GenCodec]: GenCodec[Tree[T]] = GenCodec.materialize[Tree[T]]
}
```

```scala
sealed abstract class Key[T](value: T)
case class StringKey(value: String) extends Key[String](value)
case class IntKey(value: Int) extends Key[Int](value)
case object NullKey extends Key[Null](null)
object Key {
  implicit val codec: GenCodec[Key[_]] = GenCodec.materialize[Key[_]]
}
```

### Fully automatic mode - [`GenCodec.Auto`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$$Auto.html)

As in all examples shown before, if your API accepts implicit parameters of type `GenCodec[T]` in order to be able to 
serialize or deserialize values of `T`, codecs must always be explicitly declared for all serializable types, even thought 
they could be materialized automatically. This may seem cumbersome and annoying, but first: there is a good reason for that, 
and second: there is an alternative mode where explicit codecs are not required.

If you don't want to declare codecs for every object, case class or sealed hierarchy, you can design your API around the 
[`GenCodec.Auto`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$$Auto.html) 
typeclass instead of [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html). 
[`GenCodec.Auto`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$$Auto.html) 
is just a simple wrapper around [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html). 
If some method requires implicit parameter of type `GenCodec.Auto[T]` and there is already a `GenCodec[T]` available, 
that codec will be wrapped and used. But if there is no [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html)
available, the compiler will try to materialize it on the fly using `materializeRecursively` macro.

As an example of an API build around auto codecs, [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$.html) 
companion object contains `autoRead` and `autoWrite` 
methods which accept [`GenCodec.Auto`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$$Auto.html) 
instead of [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html).

#### Explicit vs automatic mode

You may wonder now: why not always use [`GenCodec.Auto`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$$Auto.html)? 
This depends on your use case, but sometimes it's good to require programmers to explicitly declare codecs. 
Suppose that you're using [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html) 
framework to serialize values in order to save them in database. In such case, you don't want any types to be accidentally 
serialized, because once a class gets serialized into database, it's bound by backwards compatibility constraints. 
You can no longer freely refactor such class without risking that reading previously saved data from database will fail. 
That's why it's good to require that a programmer always consciously decides that a particular class can be serialized.

Even if you're using [`GenCodec.Auto`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$$Auto.html), 
it's often still beneficial to explicitly declare [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html)s 
in companion objects of your classes (remember that [`GenCodec.Auto`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec$$Auto.html) 
wraps existing [`GenCodec`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/GenCodec.html)s if they are available).
By declaring codecs explicitly one can:
* avoid bytecode duplication
* reduce compilation times
* avoid problems with incremental compilation caused by usage of macros (especially in IntelliJ IDEA)

### Customizing macro-materialized codecs

There are several annotations that can be used to alter the default behaviour of auto-materialized codecs for case classes, 
objects and sealed hierarchies. They can be found in 
[`com.avsystem.commons.serialization`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/index.html) 
package and include:

* [`@name("someName")`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/name.html) - 
  changes object field names in serialized data
  * when applied on case class field: changes the raw field name used in case class representation
  * when applied on class or object in sealed hierarchy: changes raw field name used in sealed trait/class representation 
    to determine which case is being serialized
* [`@transparent`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/transparent.html) - 
  can be used on case classes with exactly one field to instruct the auto-codec that the class should 
  be serialized to the same representation as its only field
* [`@transientDefault`](http://avsystem.github.io/scala-commons/api/com/avsystem/commons/serialization/transientDefault.html) - 
  can be used on case class fields that have a default value to instruct the auto-codec to not 
  serialize this field unless its value is different than the default value

It's also worth to remember that when deserializing case class, some fields may be missing in the representation and 
the deserialization will not fail as long as those fields have a default value.

#### Safely introducing changes to serialized classes (retaining backwards compatibility)

One must be careful when introducing changes to serialized classes so that serialized representation of old version can 
be safely deserialized into new version.

1. Changing order of fields in case class is always safe, as the order of fields in serialized objects doesn't matter
1. Adding a field to case class is safe as long as you provide default value for that field. Deserializer will use that 
   value if field is missing in the serialized data.
1. Removing a field from case class is always safe.
1. Changing name of case class field is safe as long as you annotate that field with `@name` annotation containing the old name.
1. Changing the type of case class field is safe as long as you ensure that both old and new type have the same representation. 
   The `@transparent` annotation may be useful when changing a type into some type that wraps the original type.
1. Changing default value of case class field is always safe (i.e. will not crash), but already serialized data will still 
   contain old default value (unless you use `@transientDefault` annotation).
1. Adding classes or objects to sealed hierarchy is always safe.
1. Changing name of an object or class in sealed hierarchy is safe as long as you annotate that class/object with `@name` 
   annotation containing the old name.

Of course, the above rules are guaranteed to work only for macro-materialized codecs.
If you implement your codecs manually, you're on your own.
